Index: src/algorithms/maze3D/MyMaze3DGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.maze3D;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\npublic class MyMaze3DGenerator extends AMaze3DGenerator\r\n{\r\n    private ArrayList<Position3D> walls;\r\n\r\n    @Override\r\n    public Maze3D generate(int depth, int row, int column)\r\n    {\r\n        if (depth < 2 || row < 2 || column < 2) return null;\r\n\r\n        int[][][] maze = new int[depth][row][column];\r\n\r\n        // Start with a grid full of walls\r\n        makeAllWalls(maze, depth, row, column);\r\n\r\n        Position3D start = setStartPosition(maze, depth, row, column);\r\n        walls = new ArrayList<>();\r\n        walls.add(start);\r\n        Position3D current;\r\n        int count;\r\n        int out = 0;\r\n        int in = 0;\r\n        while (!walls.isEmpty())\r\n        {\r\n            current = walls.remove((int) (Math.random() * walls.size()));\r\n            //count how many valid,0 valued neighbors current has\r\n            count = checkNumberOfVisitedNeighbors(maze, current);\r\n\r\n            if (count <= 1)\r\n            {\r\n                in++;\r\n                //break random wall\r\n                maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex()] = 0;\r\n                //add new walls to \"walls\" list if they are valid walls and actually walls:\r\n                //up\r\n                addValidAdjacentCells(maze, 0, current.getRowIndex(), current.getRowIndex() - 1, current.getColumnIndex(), current.getDepthIndex());\r\n                //left\r\n                addValidAdjacentCells(maze, 0, current.getColumnIndex(), current.getRowIndex(), current.getColumnIndex() - 1, current.getDepthIndex());\r\n                //down\r\n                addValidAdjacentCells(maze, current.getRowIndex() + 1, maze[0].length, current.getRowIndex() + 1, current.getColumnIndex(), current.getDepthIndex());\r\n                //right\r\n                addValidAdjacentCells(maze, current.getColumnIndex() + 1, maze[0][0].length, current.getRowIndex(), current.getColumnIndex() + 1, current.getDepthIndex());\r\n                //out\r\n                addValidAdjacentCells(maze, 0, current.getDepthIndex(), current.getRowIndex(), current.getColumnIndex(), current.getDepthIndex() - 1);\r\n                //in\r\n                addValidAdjacentCells(maze, current.getDepthIndex() + 1, maze.length, current.getRowIndex(), current.getColumnIndex(), current.getDepthIndex() + 1);\r\n\r\n            }\r\n            else\r\n            {\r\n                out++;\r\n            }\r\n        }\r\n\r\n        Position3D goal = setGoalPosition(maze, start);\r\n        Maze3D myMaze = new Maze3D(maze, start, goal);\r\n        return myMaze;\r\n    }\r\n\r\n    private void makeAllWalls(int[][][] maze, int depth, int row, int column)\r\n    {\r\n        for (int k = 0; k < depth; k++)\r\n        {\r\n            for (int i = 0; i < row; i++)\r\n            {\r\n                for (int j = 0; j < column; j++)\r\n                    maze[k][i][j] = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a random maze starting point\r\n     */\r\n    private Position3D setStartPosition(int[][][] maze, int depth, int row, int column)\r\n    {\r\n        Random random = new Random();\r\n        int rowIndex = random.nextInt(row);\r\n        int colIndex;\r\n        int depIndex = random.nextInt(depth);\r\n\r\n        if (rowIndex == 0 || rowIndex == row - 1 || depIndex == 0 || depIndex == depth - 1) { colIndex = random.nextInt(column); }\r\n\r\n        else { colIndex = ((int) Math.round(Math.random())) * (column - 1); }\r\n\r\n        maze[depIndex][rowIndex][colIndex] = 0;\r\n\r\n        Position3D start = new Position3D(rowIndex, colIndex, depIndex);\r\n        return start;\r\n    }\r\n\r\n    private Position3D setGoalPosition(int[][][] maze, Position3D start)\r\n    {\r\n        Random r = new Random();\r\n        int rowIndex = start.getRowIndex();\r\n        int colIndex = start.getColumnIndex();\r\n        int depIndex = start.getDepthIndex();\r\n        while ((start.getRowIndex() == rowIndex && start.getColumnIndex() == colIndex && start.getDepthIndex() == depIndex) || maze[depIndex][rowIndex][colIndex] == 1)\r\n        {\r\n            //pick a random row\r\n            rowIndex = r.nextInt(maze[0].length);\r\n            //pick a random depth\r\n            depIndex = r.nextInt(maze.length);\r\n            //if the row is first or last-pick a random cell\r\n            //else-pick col 0 or end col randomly\r\n            if (rowIndex == 0 || rowIndex == maze[0].length - 1 || depIndex == maze.length - 1 || depIndex == 0)\r\n            {\r\n                colIndex = r.nextInt(maze[0][0].length);\r\n            }\r\n            else\r\n            {\r\n                colIndex = ((int) (Math.round(Math.random())) * (maze[0].length - 1));\r\n            }\r\n\r\n        }\r\n        maze[depIndex][rowIndex][colIndex] = 0;//todo:is this ok?\r\n        Position3D goal = new Position3D(rowIndex, colIndex, depIndex);\r\n        return goal;\r\n    }\r\n\r\n    /**\r\n     * returns the number of neighbors that has the value of 0 and in the valid range of the maze\r\n     */\r\n    private int checkNumberOfVisitedNeighbors(int[][][] maze, Position3D current)\r\n    {\r\n        int numOfValidNeighbors = 0;\r\n        //up\r\n        if (current.getRowIndex() - 1 > 0 && maze[current.getDepthIndex()][current.getRowIndex() - 1][current.getColumnIndex()] == 0) numOfValidNeighbors++;\r\n        //down\r\n        if (current.getRowIndex() + 1 < maze[0].length && maze[current.getDepthIndex()][current.getRowIndex() + 1][current.getColumnIndex()] == 0) numOfValidNeighbors++;\r\n        //left\r\n        if (current.getColumnIndex() - 1 > 0 && maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex() - 1] == 0) numOfValidNeighbors++;\r\n        //right\r\n        if (current.getColumnIndex() + 1 < maze[0][0].length && maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex() + 1] == 0) numOfValidNeighbors++;\r\n        ///in\r\n        if (current.getDepthIndex() + 1 < maze.length && maze[current.getDepthIndex() + 1][current.getRowIndex()][current.getColumnIndex()] == 0) numOfValidNeighbors++;\r\n        //out\r\n        if (current.getDepthIndex() - 1 > 0 && maze[current.getDepthIndex() - 1][current.getRowIndex()][current.getColumnIndex()] == 0) numOfValidNeighbors++;\r\n\r\n        return numOfValidNeighbors;\r\n    }\r\n\r\n    private void addValidAdjacentCells(int[][][] maze, int bottom, int upper, int row, int col, int dep)\r\n    {\r\n        if (bottom < upper && maze[dep][row][col] == 1)\r\n        {\r\n            Position3D position = new Position3D(dep, row, col);\r\n            walls.add(position);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/algorithms/maze3D/MyMaze3DGenerator.java	(revision ee82a5541d2c5b6882ae531a3fcbb660dfa70e35)
+++ src/algorithms/maze3D/MyMaze3DGenerator.java	(date 1618341141218)
@@ -89,7 +89,7 @@
 
         maze[depIndex][rowIndex][colIndex] = 0;
 
-        Position3D start = new Position3D(rowIndex, colIndex, depIndex);
+        Position3D start = new Position3D(depIndex, rowIndex, colIndex);
         return start;
     }
 
@@ -118,7 +118,7 @@
 
         }
         maze[depIndex][rowIndex][colIndex] = 0;//todo:is this ok?
-        Position3D goal = new Position3D(rowIndex, colIndex, depIndex);
+        Position3D goal = new Position3D(depIndex, rowIndex, colIndex);
         return goal;
     }
 
@@ -129,17 +129,17 @@
     {
         int numOfValidNeighbors = 0;
         //up
-        if (current.getRowIndex() - 1 > 0 && maze[current.getDepthIndex()][current.getRowIndex() - 1][current.getColumnIndex()] == 0) numOfValidNeighbors++;
+        if (current.getRowIndex() - 1 >= 0 && maze[current.getDepthIndex()][current.getRowIndex() - 1][current.getColumnIndex()] == 0) numOfValidNeighbors++;
         //down
         if (current.getRowIndex() + 1 < maze[0].length && maze[current.getDepthIndex()][current.getRowIndex() + 1][current.getColumnIndex()] == 0) numOfValidNeighbors++;
         //left
-        if (current.getColumnIndex() - 1 > 0 && maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex() - 1] == 0) numOfValidNeighbors++;
+        if (current.getColumnIndex() - 1 >= 0 && maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex() - 1] == 0) numOfValidNeighbors++;
         //right
         if (current.getColumnIndex() + 1 < maze[0][0].length && maze[current.getDepthIndex()][current.getRowIndex()][current.getColumnIndex() + 1] == 0) numOfValidNeighbors++;
         ///in
         if (current.getDepthIndex() + 1 < maze.length && maze[current.getDepthIndex() + 1][current.getRowIndex()][current.getColumnIndex()] == 0) numOfValidNeighbors++;
         //out
-        if (current.getDepthIndex() - 1 > 0 && maze[current.getDepthIndex() - 1][current.getRowIndex()][current.getColumnIndex()] == 0) numOfValidNeighbors++;
+        if (current.getDepthIndex() - 1 >= 0 && maze[current.getDepthIndex() - 1][current.getRowIndex()][current.getColumnIndex()] == 0) numOfValidNeighbors++;
 
         return numOfValidNeighbors;
     }
Index: JUnit/algorithms/search/BestFirstSearchTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.search;\r\n\r\nimport algorithms.maze3D.*;\r\nimport algorithms.mazeGenerators.*;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.util.ArrayList;\r\n\r\n\r\nclass BestFirstSearchTest\r\n{\r\n    private Maze maze;\r\n    private Maze3D maze3D;\r\n    private SearchableMaze searchableMaze;\r\n    private EmptyMazeGenerator emptyMaze = new EmptyMazeGenerator();\r\n    private SimpleMazeGenerator simpleMaze = new SimpleMazeGenerator();\r\n    private MyMazeGenerator myMaze2D = new MyMazeGenerator();\r\n    private MyMaze3DGenerator myMaze3D = new MyMaze3DGenerator();\r\n    private ISearchingAlgorithm best = new BestFirstSearch();\r\n\r\n    @Test\r\n    public void GetAlgorithmNameTest()\r\n    {\r\n        assertEquals(\"BestFirstSearch\", best.getName());\r\n    }\r\n\r\n    @Test\r\n    public void notNullTest()\r\n    {\r\n        assertNull(emptyMaze.generate(-2,4));\r\n        assertNull(simpleMaze.generate(-10, -10));\r\n        assertNull(myMaze2D.generate(0,0));\r\n        assertNull(myMaze3D.generate(4,-9,10));\r\n    }\r\n\r\n    @Test\r\n    public void mazeSizeTest()\r\n    {\r\n        maze = simpleMaze.generate(100, 200);\r\n        searchableMaze = new SearchableMaze(maze);\r\n        assertEquals(maze.getRowSize(), 100);\r\n        assertEquals(maze.getColSize(), 200);\r\n    }\r\n\r\n    @Test\r\n    public void getNumOfNodesEvaluatedTest()\r\n    {\r\n        best.solve(null);\r\n        assertEquals(best.getNumberOfNodesEvaluated(), 0);\r\n    }\r\n\r\n    @Test\r\n    public void solve2DMazeTest()\r\n    {\r\n        solve2DAssert(emptyMaze, 2, 2);\r\n        solve2DAssert(emptyMaze, 60, 50);\r\n        solve2DAssert(emptyMaze, 1000, 1000);\r\n        solve2DAssert(simpleMaze, 2,3);\r\n        solve2DAssert(simpleMaze, 3,2);\r\n        solve2DAssert(simpleMaze, 67, 57);\r\n        solve2DAssert(simpleMaze, 1000, 650);\r\n        solve2DAssert(simpleMaze, 1000,1000);\r\n        solve2DAssert(myMaze2D, 2, 2);\r\n        solve2DAssert(myMaze2D, 2, 3);\r\n        solve2DAssert(myMaze2D, 3, 2);\r\n        solve2DAssert(myMaze2D, 6, 5);\r\n        solve2DAssert(myMaze2D, 5, 6);\r\n        solve2DAssert(myMaze2D, 111, 111);\r\n        solve2DAssert(myMaze2D, 1000, 1000);\r\n\r\n    }\r\n\r\n    private void solve2DAssert(IMazeGenerator mazeGenerator, int row, int column)\r\n    {\r\n        maze = mazeGenerator.generate(row, column);\r\n        searchableMaze = new SearchableMaze(maze);\r\n        Solution solution = best.solve(searchableMaze);\r\n        ArrayList<AState> solutionPath = solution.getSolutionPath();\r\n\r\n        System.out.println(solutionPath.get(solutionPath.size()-1).toString());\r\n        assertEquals(maze.getStartPosition().toString(), solutionPath.get(0).toString());\r\n        assertEquals(maze.getGoalPosition().toString(), solutionPath.get(solutionPath.size()-1).toString());\r\n    }\r\n\r\n    // testing generate and start & goal positions are correct in the solution of empty Maze\r\n    @Test\r\n    public void solveEmptyMaze()\r\n    {\r\n        EmptyMazeGenerator myEmptyMaze = new EmptyMazeGenerator();\r\n        Maze emptyMaze = myEmptyMaze.generate(1000,1000);\r\n        searchableMaze = new SearchableMaze(emptyMaze);\r\n        Solution solveEmptyMaze = best.solve(searchableMaze);\r\n        ArrayList<AState> solution = solveEmptyMaze.getSolutionPath();\r\n        Assertions.assertEquals(emptyMaze.getGoalPosition().toString(),solution.get(solution.size()-1).toString());\r\n        Assertions.assertEquals(emptyMaze.getStartPosition().toString(),solution.get(0).toString());\r\n    }\r\n\r\n    // testing generate and start & goal positions are correct in the solution of simple Maze\r\n    @Test\r\n    public void solveSimpleMaze()\r\n    {\r\n        SimpleMazeGenerator mySimpleMaze = new SimpleMazeGenerator();\r\n        Maze simpleMaze = mySimpleMaze.generate(1000,1000);\r\n        searchableMaze = new SearchableMaze(simpleMaze);\r\n        Solution solveEmptyMaze = best.solve(searchableMaze);\r\n        ArrayList<AState> solution = solveEmptyMaze.getSolutionPath();\r\n        Assertions.assertEquals(simpleMaze.getGoalPosition().toString(),solution.get(solution.size()-1).toString());\r\n        Assertions.assertEquals(simpleMaze.getStartPosition().toString(),solution.get(0).toString());\r\n\r\n    }\r\n\r\n    // testing generate and start & goal positions are correct in the solution of my Maze\r\n    @Test\r\n    public void solveMyMaze()\r\n    {\r\n        MyMazeGenerator myMyMaze = new MyMazeGenerator();\r\n        Maze myMaze = myMyMaze.generate(1000,1000);\r\n        searchableMaze = new SearchableMaze(myMaze);\r\n        Solution solveMaze = best.solve(searchableMaze);\r\n        ArrayList<AState> solution = solveMaze.getSolutionPath();\r\n        Assertions.assertEquals(myMaze.getGoalPosition().toString(),solution.get(solution.size()-1).toString());\r\n        Assertions.assertEquals(myMaze.getStartPosition().toString(),solution.get(0).toString());\r\n    }\r\n\r\n    @Test\r\n    void solveInMinute() {\r\n        BestFirstSearch BFS = new BestFirstSearch();\r\n\r\n        MyMazeGenerator myMaze = new MyMazeGenerator();\r\n        Maze maze = myMaze.generate(1000, 1000);\r\n        SearchableMaze searchableMaze = new SearchableMaze(maze);\r\n        long before = System.currentTimeMillis();\r\n        BFS.solve(searchableMaze);\r\n        long time = System.currentTimeMillis() - before;\r\n        Assertions.assertTrue(time <= 60000);\r\n    }\r\n\r\n\r\n    @Test\r\n    public void solving3DMazes() {\r\n        solving3DAssert(2 ,2,2);\r\n        solving3DAssert(2 ,3,2);\r\n        solving3DAssert(3 ,3,3);\r\n        solving3DAssert(57 ,61,4);\r\n        solving3DAssert(100 ,100,100);\r\n    }\r\n\r\n    public void solving3DAssert(int dep ,int row,int col)\r\n    {\r\n        ISearchingAlgorithm best = new BestFirstSearch();\r\n        IMaze3DGenerator iMaze3DGenerator = new MyMaze3DGenerator();\r\n        Maze3D maze = iMaze3DGenerator.generate(dep, row, col);\r\n        SearchableMaze3D sm = new SearchableMaze3D(maze);\r\n        Solution s = best.solve(sm);\r\n        AState blank = null;\r\n        assert s != null;\r\n        assert s.getSolutionPath().size() >= 1;\r\n        assert s.getSolutionPath().contains(new Maze3DState(maze.getGoalPosition(), 0, blank));\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JUnit/algorithms/search/BestFirstSearchTest.java	(revision ee82a5541d2c5b6882ae531a3fcbb660dfa70e35)
+++ JUnit/algorithms/search/BestFirstSearchTest.java	(date 1618341246839)
@@ -109,7 +109,6 @@
         ArrayList<AState> solution = solveEmptyMaze.getSolutionPath();
         Assertions.assertEquals(simpleMaze.getGoalPosition().toString(),solution.get(solution.size()-1).toString());
         Assertions.assertEquals(simpleMaze.getStartPosition().toString(),solution.get(0).toString());
-
     }
 
     // testing generate and start & goal positions are correct in the solution of my Maze
